{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { forwardRef, Directive, Inject, EventEmitter, Input, Output, HostBinding, HostListener, ContentChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nconst DROP_EFFECTS = [\"move\", \"copy\", \"link\"];\nconst CUSTOM_MIME_TYPE = \"application/x-dnd\";\nconst JSON_MIME_TYPE = \"application/json\";\nconst MSIE_MIME_TYPE = \"Text\";\n\nfunction mimeTypeIsCustom(mimeType) {\n  return mimeType.substr(0, CUSTOM_MIME_TYPE.length) === CUSTOM_MIME_TYPE;\n}\n\nfunction getWellKnownMimeType(event) {\n  if (event.dataTransfer) {\n    const types = event.dataTransfer.types; // IE 9 workaround.\n\n    if (!types) {\n      return MSIE_MIME_TYPE;\n    }\n\n    for (let i = 0; i < types.length; i++) {\n      if (types[i] === MSIE_MIME_TYPE || types[i] === JSON_MIME_TYPE || mimeTypeIsCustom(types[i])) {\n        return types[i];\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction setDragData(event, data, effectAllowed) {\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n  const mimeType = CUSTOM_MIME_TYPE + (data.type ? \"-\" + data.type : \"\");\n  const dataString = JSON.stringify(data);\n\n  try {\n    event.dataTransfer?.setData(mimeType, dataString);\n  } catch (e) {\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\n    try {\n      event.dataTransfer?.setData(JSON_MIME_TYPE, dataString);\n    } catch (e) {\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\n      //   the one we want to display now by setting effectAllowed.\n      const effectsAllowed = filterEffects(DROP_EFFECTS, effectAllowed);\n\n      if (event.dataTransfer) {\n        event.dataTransfer.effectAllowed = effectsAllowed[0];\n      }\n\n      event.dataTransfer?.setData(MSIE_MIME_TYPE, dataString);\n    }\n  }\n}\n\nfunction getDropData(event, dragIsExternal) {\n  // check if the mime type is well known\n  const mimeType = getWellKnownMimeType(event); // drag did not originate from [dndDraggable]\n\n  if (dragIsExternal === true) {\n    if (mimeType !== null && mimeTypeIsCustom(mimeType)) {\n      // the type of content is well known and safe to handle\n      return JSON.parse(event.dataTransfer?.getData(mimeType) ?? \"{}\");\n    } // the contained data is unknown, let user handle it\n\n\n    return {};\n  }\n\n  if (mimeType !== null) {\n    // the type of content is well known and safe to handle\n    return JSON.parse(event.dataTransfer?.getData(mimeType) ?? \"{}\");\n  } // the contained data is unknown, let user handle it\n\n\n  return {};\n}\n\nfunction filterEffects(effects, allowed) {\n  if (allowed === \"all\" || allowed === \"uninitialized\") {\n    return effects;\n  }\n\n  return effects.filter(function (effect) {\n    return allowed.toLowerCase().indexOf(effect) !== -1;\n  });\n}\n\nfunction getDirectChildElement(parentElement, childElement) {\n  let directChild = childElement;\n\n  while (directChild.parentNode !== parentElement) {\n    // reached root node without finding given parent\n    if (!directChild.parentNode) {\n      return null;\n    }\n\n    directChild = directChild.parentNode;\n  }\n\n  return directChild;\n}\n\nfunction shouldPositionPlaceholderBeforeElement(event, element, horizontal) {\n  const bounds = element.getBoundingClientRect(); // If the pointer is in the upper half of the list item element,\n  // we position the placeholder before the list item, otherwise after it.\n\n  if (horizontal) {\n    return event.clientX < bounds.left + bounds.width / 2;\n  }\n\n  return event.clientY < bounds.top + bounds.height / 2;\n}\n\nfunction calculateDragImageOffset(event, dragImage) {\n  const dragImageComputedStyle = window.getComputedStyle(dragImage);\n  const paddingTop = parseFloat(dragImageComputedStyle.paddingTop) || 0;\n  const paddingLeft = parseFloat(dragImageComputedStyle.paddingLeft) || 0;\n  const borderTop = parseFloat(dragImageComputedStyle.borderTopWidth) || 0;\n  const borderLeft = parseFloat(dragImageComputedStyle.borderLeftWidth) || 0;\n  return {\n    x: event.offsetX + paddingLeft + borderLeft,\n    y: event.offsetY + paddingTop + borderTop\n  };\n}\n\nfunction setDragImage(event, dragImage, offsetFunction) {\n  const offset = offsetFunction(event, dragImage) || {\n    x: 0,\n    y: 0\n  };\n  event.dataTransfer.setDragImage(dragImage, offset.x, offset.y);\n}\n\nconst _dndState = {\n  isDragging: false,\n  dropEffect: \"none\",\n  effectAllowed: \"all\",\n  type: undefined\n};\n\nfunction startDrag(event, effectAllowed, type) {\n  _dndState.isDragging = true;\n  _dndState.dropEffect = \"none\";\n  _dndState.effectAllowed = effectAllowed;\n  _dndState.type = type;\n\n  if (event.dataTransfer) {\n    event.dataTransfer.effectAllowed = effectAllowed;\n  }\n}\n\nfunction endDrag() {\n  _dndState.isDragging = false;\n  _dndState.dropEffect = undefined;\n  _dndState.effectAllowed = undefined;\n  _dndState.type = undefined;\n}\n\nfunction setDropEffect(event, dropEffect) {\n  if (_dndState.isDragging === true) {\n    _dndState.dropEffect = dropEffect;\n  }\n\n  if (event.dataTransfer) {\n    event.dataTransfer.dropEffect = dropEffect;\n  }\n}\n\nfunction getDropEffect(event, effectAllowed) {\n  const dataTransferEffectAllowed = event.dataTransfer ? event.dataTransfer.effectAllowed : \"uninitialized\";\n  let effects = filterEffects(DROP_EFFECTS, dataTransferEffectAllowed);\n\n  if (_dndState.isDragging === true) {\n    effects = filterEffects(effects, _dndState.effectAllowed);\n  }\n\n  if (effectAllowed) {\n    effects = filterEffects(effects, effectAllowed);\n  } // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n  // therefore the following modifier keys will only affect other operating systems.\n\n\n  if (effects.length === 0) {\n    return \"none\";\n  }\n\n  if (event.ctrlKey && effects.indexOf(\"copy\") !== -1) {\n    return \"copy\";\n  }\n\n  if (event.altKey && effects.indexOf(\"link\") !== -1) {\n    return \"link\";\n  }\n\n  return effects[0];\n}\n\nfunction getDndType(event) {\n  if (_dndState.isDragging === true) {\n    return _dndState.type;\n  }\n\n  const mimeType = getWellKnownMimeType(event);\n\n  if (mimeType === null) {\n    return undefined;\n  }\n\n  if (mimeType === MSIE_MIME_TYPE || mimeType === JSON_MIME_TYPE) {\n    return undefined;\n  }\n\n  return mimeType.substr(CUSTOM_MIME_TYPE.length + 1) || undefined;\n}\n\nfunction isExternalDrag() {\n  return _dndState.isDragging === false;\n}\n\nconst dndState = _dndState;\n\nclass DndDragImageRefDirective {\n  constructor(parent, elementRef) {\n    parent.registerDragImage(elementRef);\n  }\n\n}\n\nDndDragImageRefDirective.ɵfac = function DndDragImageRefDirective_Factory(t) {\n  return new (t || DndDragImageRefDirective)(i0.ɵɵdirectiveInject(forwardRef(() => DndDraggableDirective)), i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nDndDragImageRefDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DndDragImageRefDirective,\n  selectors: [[\"\", \"dndDragImageRef\", \"\"]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DndDragImageRefDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndDragImageRef]\"\n    }]\n  }], function () {\n    return [{\n      type: DndDraggableDirective,\n      decorators: [{\n        type: Inject,\n        args: [forwardRef(() => DndDraggableDirective)]\n      }]\n    }, {\n      type: i0.ElementRef\n    }];\n  }, null);\n})();\n\nclass DndDraggableDirective {\n  constructor(elementRef, renderer, ngZone) {\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.ngZone = ngZone;\n    this.dndEffectAllowed = \"copy\";\n    this.dndDraggingClass = \"dndDragging\";\n    this.dndDraggingSourceClass = \"dndDraggingSource\";\n    this.dndDraggableDisabledClass = \"dndDraggableDisabled\";\n    this.dndDragImageOffsetFunction = calculateDragImageOffset;\n    this.dndStart = new EventEmitter();\n    this.dndDrag = new EventEmitter();\n    this.dndEnd = new EventEmitter();\n    this.dndMoved = new EventEmitter();\n    this.dndCopied = new EventEmitter();\n    this.dndLinked = new EventEmitter();\n    this.dndCanceled = new EventEmitter();\n    this.draggable = true;\n    this.isDragStarted = false;\n\n    this.dragEventHandler = event => this.onDrag(event);\n  }\n\n  set dndDisableIf(value) {\n    this.draggable = !value;\n\n    if (this.draggable) {\n      this.renderer.removeClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n    } else {\n      this.renderer.addClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n    }\n  }\n\n  set dndDisableDragIf(value) {\n    this.dndDisableIf = value;\n  }\n\n  ngAfterViewInit() {\n    this.ngZone.runOutsideAngular(() => {\n      this.elementRef.nativeElement.addEventListener(\"drag\", this.dragEventHandler);\n    });\n  }\n\n  ngOnDestroy() {\n    this.elementRef.nativeElement.removeEventListener(\"drag\", this.dragEventHandler);\n\n    if (this.isDragStarted === true) {\n      endDrag();\n    }\n  }\n\n  onDragStart(event) {\n    if (this.draggable === false) {\n      return false;\n    } // check if there is dnd handle and if the dnd handle was used to start the drag\n\n\n    if (typeof this.dndHandle !== \"undefined\" && typeof event._dndUsingHandle === \"undefined\") {\n      return false;\n    } // initialize global state\n\n\n    startDrag(event, this.dndEffectAllowed, this.dndType);\n    this.isDragStarted = true;\n    setDragData(event, {\n      data: this.dndDraggable,\n      type: this.dndType\n    }, dndState.effectAllowed);\n    this.dragImage = this.determineDragImage(); // set dragging css class prior to setDragImage so styles are applied before\n    // TODO breaking change: add class to elementRef rather than drag image which could be another element\n\n    this.renderer.addClass(this.dragImage, this.dndDraggingClass); // set custom dragimage if present\n    // set dragimage if drag is started from dndHandle\n\n    if (typeof this.dndDragImageElementRef !== \"undefined\" || typeof event._dndUsingHandle !== \"undefined\") {\n      setDragImage(event, this.dragImage, this.dndDragImageOffsetFunction);\n    } // add dragging source css class on first drag event\n\n\n    const unregister = this.renderer.listen(this.elementRef.nativeElement, \"drag\", () => {\n      this.renderer.addClass(this.elementRef.nativeElement, this.dndDraggingSourceClass);\n      unregister();\n    });\n    this.dndStart.emit(event);\n    event.stopPropagation();\n    return true;\n  }\n\n  onDrag(event) {\n    this.dndDrag.emit(event);\n  }\n\n  onDragEnd(event) {\n    // get drop effect from custom stored state as its not reliable across browsers\n    const dropEffect = dndState.dropEffect;\n    let dropEffectEmitter;\n\n    switch (dropEffect) {\n      case \"copy\":\n        dropEffectEmitter = this.dndCopied;\n        break;\n\n      case \"link\":\n        dropEffectEmitter = this.dndLinked;\n        break;\n\n      case \"move\":\n        dropEffectEmitter = this.dndMoved;\n        break;\n\n      default:\n        dropEffectEmitter = this.dndCanceled;\n        break;\n    }\n\n    dropEffectEmitter.emit(event);\n    this.dndEnd.emit(event); // reset global state\n\n    endDrag();\n    this.isDragStarted = false;\n    this.renderer.removeClass(this.dragImage, this.dndDraggingClass); // IE9 special hammering\n\n    window.setTimeout(() => {\n      this.renderer.removeClass(this.elementRef.nativeElement, this.dndDraggingSourceClass);\n    }, 0);\n    event.stopPropagation();\n  }\n\n  registerDragHandle(handle) {\n    this.dndHandle = handle;\n  }\n\n  registerDragImage(elementRef) {\n    this.dndDragImageElementRef = elementRef;\n  }\n\n  determineDragImage() {\n    // evaluate custom drag image existence\n    if (typeof this.dndDragImageElementRef !== \"undefined\") {\n      return this.dndDragImageElementRef.nativeElement;\n    } else {\n      return this.elementRef.nativeElement;\n    }\n  }\n\n}\n\nDndDraggableDirective.ɵfac = function DndDraggableDirective_Factory(t) {\n  return new (t || DndDraggableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nDndDraggableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DndDraggableDirective,\n  selectors: [[\"\", \"dndDraggable\", \"\"]],\n  hostVars: 1,\n  hostBindings: function DndDraggableDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"dragstart\", function DndDraggableDirective_dragstart_HostBindingHandler($event) {\n        return ctx.onDragStart($event);\n      })(\"dragend\", function DndDraggableDirective_dragend_HostBindingHandler($event) {\n        return ctx.onDragEnd($event);\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵattribute(\"draggable\", ctx.draggable);\n    }\n  },\n  inputs: {\n    dndDraggable: \"dndDraggable\",\n    dndEffectAllowed: \"dndEffectAllowed\",\n    dndType: \"dndType\",\n    dndDraggingClass: \"dndDraggingClass\",\n    dndDraggingSourceClass: \"dndDraggingSourceClass\",\n    dndDraggableDisabledClass: \"dndDraggableDisabledClass\",\n    dndDragImageOffsetFunction: \"dndDragImageOffsetFunction\",\n    dndDisableIf: \"dndDisableIf\",\n    dndDisableDragIf: \"dndDisableDragIf\"\n  },\n  outputs: {\n    dndStart: \"dndStart\",\n    dndDrag: \"dndDrag\",\n    dndEnd: \"dndEnd\",\n    dndMoved: \"dndMoved\",\n    dndCopied: \"dndCopied\",\n    dndLinked: \"dndLinked\",\n    dndCanceled: \"dndCanceled\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DndDraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndDraggable]\"\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    dndDraggable: [{\n      type: Input\n    }],\n    dndEffectAllowed: [{\n      type: Input\n    }],\n    dndType: [{\n      type: Input\n    }],\n    dndDraggingClass: [{\n      type: Input\n    }],\n    dndDraggingSourceClass: [{\n      type: Input\n    }],\n    dndDraggableDisabledClass: [{\n      type: Input\n    }],\n    dndDragImageOffsetFunction: [{\n      type: Input\n    }],\n    dndStart: [{\n      type: Output\n    }],\n    dndDrag: [{\n      type: Output\n    }],\n    dndEnd: [{\n      type: Output\n    }],\n    dndMoved: [{\n      type: Output\n    }],\n    dndCopied: [{\n      type: Output\n    }],\n    dndLinked: [{\n      type: Output\n    }],\n    dndCanceled: [{\n      type: Output\n    }],\n    draggable: [{\n      type: HostBinding,\n      args: [\"attr.draggable\"]\n    }],\n    dndDisableIf: [{\n      type: Input\n    }],\n    dndDisableDragIf: [{\n      type: Input\n    }],\n    onDragStart: [{\n      type: HostListener,\n      args: [\"dragstart\", [\"$event\"]]\n    }],\n    onDragEnd: [{\n      type: HostListener,\n      args: [\"dragend\", [\"$event\"]]\n    }]\n  });\n})();\n\nclass DndPlaceholderRefDirective {\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n  }\n\n}\n\nDndPlaceholderRefDirective.ɵfac = function DndPlaceholderRefDirective_Factory(t) {\n  return new (t || DndPlaceholderRefDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nDndPlaceholderRefDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DndPlaceholderRefDirective,\n  selectors: [[\"\", \"dndPlaceholderRef\", \"\"]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DndPlaceholderRefDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndPlaceholderRef]\"\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }];\n  }, null);\n})();\n\nclass DndDropzoneDirective {\n  constructor(ngZone, elementRef, renderer) {\n    this.ngZone = ngZone;\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.dndDropzone = \"\";\n    this.dndEffectAllowed = \"uninitialized\";\n    this.dndAllowExternal = false;\n    this.dndHorizontal = false;\n    this.dndDragoverClass = \"dndDragover\";\n    this.dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\n    this.dndDragover = new EventEmitter();\n    this.dndDrop = new EventEmitter();\n    this.placeholder = null;\n    this.disabled = false;\n\n    this.dragEnterEventHandler = event => this.onDragEnter(event);\n\n    this.dragOverEventHandler = event => this.onDragOver(event);\n\n    this.dragLeaveEventHandler = event => this.onDragLeave(event);\n  }\n\n  set dndDisableIf(value) {\n    this.disabled = !!value;\n\n    if (this.disabled) {\n      this.renderer.addClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n    } else {\n      this.renderer.removeClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n    }\n  }\n\n  set dndDisableDropIf(value) {\n    this.dndDisableIf = value;\n  }\n\n  ngAfterViewInit() {\n    this.placeholder = this.tryGetPlaceholder();\n    this.removePlaceholderFromDOM();\n    this.ngZone.runOutsideAngular(() => {\n      this.elementRef.nativeElement.addEventListener(\"dragenter\", this.dragEnterEventHandler);\n      this.elementRef.nativeElement.addEventListener(\"dragover\", this.dragOverEventHandler);\n      this.elementRef.nativeElement.addEventListener(\"dragleave\", this.dragLeaveEventHandler);\n    });\n  }\n\n  ngOnDestroy() {\n    this.elementRef.nativeElement.removeEventListener(\"dragenter\", this.dragEnterEventHandler);\n    this.elementRef.nativeElement.removeEventListener(\"dragover\", this.dragOverEventHandler);\n    this.elementRef.nativeElement.removeEventListener(\"dragleave\", this.dragLeaveEventHandler);\n  }\n\n  onDragEnter(event) {\n    // check if another dropzone is activated\n    if (event._dndDropzoneActive === true) {\n      this.cleanupDragoverState();\n      return;\n    } // set as active if the target element is inside this dropzone\n\n\n    if (typeof event._dndDropzoneActive === \"undefined\") {\n      const newTarget = document.elementFromPoint(event.clientX, event.clientY);\n\n      if (this.elementRef.nativeElement.contains(newTarget)) {\n        event._dndDropzoneActive = true;\n      }\n    } // check if this drag event is allowed to drop on this dropzone\n\n\n    const type = getDndType(event);\n\n    if (this.isDropAllowed(type) === false) {\n      return;\n    } // allow the dragenter\n\n\n    event.preventDefault();\n  }\n\n  onDragOver(event) {\n    // With nested dropzones, we want to ignore this event if a child dropzone\n    // has already handled a dragover.  Historically, event.stopPropagation() was\n    // used to prevent this bubbling, but that prevents any dragovers outside the\n    // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\n    // Instead, we can check if the event was already prevented by a child and bail early.\n    if (event.defaultPrevented) {\n      return;\n    } // check if this drag event is allowed to drop on this dropzone\n\n\n    const type = getDndType(event);\n\n    if (this.isDropAllowed(type) === false) {\n      return;\n    }\n\n    this.checkAndUpdatePlaceholderPosition(event);\n    const dropEffect = getDropEffect(event, this.dndEffectAllowed);\n\n    if (dropEffect === \"none\") {\n      this.cleanupDragoverState();\n      return;\n    } // allow the dragover\n\n\n    event.preventDefault(); // set the drop effect\n\n    setDropEffect(event, dropEffect);\n    this.dndDragover.emit(event);\n    this.renderer.addClass(this.elementRef.nativeElement, this.dndDragoverClass);\n  }\n\n  onDrop(event) {\n    try {\n      // check if this drag event is allowed to drop on this dropzone\n      const type = getDndType(event);\n\n      if (this.isDropAllowed(type) === false) {\n        return;\n      }\n\n      const data = getDropData(event, isExternalDrag());\n\n      if (this.isDropAllowed(data.type) === false) {\n        return;\n      } // signal custom drop handling\n\n\n      event.preventDefault();\n      const dropEffect = getDropEffect(event);\n      setDropEffect(event, dropEffect);\n\n      if (dropEffect === \"none\") {\n        return;\n      }\n\n      const dropIndex = this.getPlaceholderIndex(); // if for whatever reason the placeholder is not present in the DOM but it should be there\n      // we don't allow/emit the drop event since it breaks the contract\n      // seems to only happen if drag and drop is executed faster than the DOM updates\n\n      if (dropIndex === -1) {\n        return;\n      }\n\n      this.dndDrop.emit({\n        event: event,\n        dropEffect: dropEffect,\n        isExternal: isExternalDrag(),\n        data: data.data,\n        index: dropIndex,\n        type: type\n      });\n      event.stopPropagation();\n    } finally {\n      this.cleanupDragoverState();\n    }\n  }\n\n  onDragLeave(event) {\n    // check if still inside this dropzone and not yet handled by another dropzone\n    if (typeof event._dndDropzoneActive === \"undefined\") {\n      const newTarget = document.elementFromPoint(event.clientX, event.clientY);\n\n      if (this.elementRef.nativeElement.contains(newTarget)) {\n        event._dndDropzoneActive = true;\n        return;\n      }\n    }\n\n    this.cleanupDragoverState(); // cleanup drop effect when leaving dropzone\n\n    setDropEffect(event, \"none\");\n  }\n\n  isDropAllowed(type) {\n    // dropzone is disabled -> deny it\n    if (this.disabled === true) {\n      return false;\n    } // if drag did not start from our directive\n    // and external drag sources are not allowed -> deny it\n\n\n    if (isExternalDrag() === true && this.dndAllowExternal === false) {\n      return false;\n    } // no filtering by types -> allow it\n\n\n    if (!this.dndDropzone) {\n      return true;\n    } // no type set -> allow it\n\n\n    if (!type) {\n      return true;\n    }\n\n    if (Array.isArray(this.dndDropzone) === false) {\n      throw new Error(\"dndDropzone: bound value to [dndDropzone] must be an array!\");\n    } // if dropzone contains type -> allow it\n\n\n    return this.dndDropzone.indexOf(type) !== -1;\n  }\n\n  tryGetPlaceholder() {\n    if (typeof this.dndPlaceholderRef !== \"undefined\") {\n      return this.dndPlaceholderRef.elementRef.nativeElement;\n    } // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\n    // of wrong context see angular bug https://github.com/angular/angular/issues/13517\n\n\n    return this.elementRef.nativeElement.querySelector(\"[dndPlaceholderRef]\");\n  }\n\n  removePlaceholderFromDOM() {\n    if (this.placeholder !== null && this.placeholder.parentNode !== null) {\n      this.placeholder.parentNode.removeChild(this.placeholder);\n    }\n  }\n\n  checkAndUpdatePlaceholderPosition(event) {\n    if (this.placeholder === null) {\n      return;\n    } // make sure the placeholder is in the DOM\n\n\n    if (this.placeholder.parentNode !== this.elementRef.nativeElement) {\n      this.renderer.appendChild(this.elementRef.nativeElement, this.placeholder);\n    } // update the position if the event originates from a child element of the dropzone\n\n\n    const directChild = getDirectChildElement(this.elementRef.nativeElement, event.target); // early exit if no direct child or direct child is placeholder\n\n    if (directChild === null || directChild === this.placeholder) {\n      return;\n    }\n\n    const positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement(event, directChild, this.dndHorizontal);\n\n    if (positionPlaceholderBeforeDirectChild) {\n      // do insert before only if necessary\n      if (directChild.previousSibling !== this.placeholder) {\n        this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild);\n      }\n    } else {\n      // do insert after only if necessary\n      if (directChild.nextSibling !== this.placeholder) {\n        this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild.nextSibling);\n      }\n    }\n  }\n\n  getPlaceholderIndex() {\n    if (this.placeholder === null) {\n      return undefined;\n    }\n\n    const element = this.elementRef.nativeElement;\n    return Array.prototype.indexOf.call(element.children, this.placeholder);\n  }\n\n  cleanupDragoverState() {\n    this.renderer.removeClass(this.elementRef.nativeElement, this.dndDragoverClass);\n    this.removePlaceholderFromDOM();\n  }\n\n}\n\nDndDropzoneDirective.ɵfac = function DndDropzoneDirective_Factory(t) {\n  return new (t || DndDropzoneDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n};\n\nDndDropzoneDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DndDropzoneDirective,\n  selectors: [[\"\", \"dndDropzone\", \"\"]],\n  contentQueries: function DndDropzoneDirective_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, DndPlaceholderRefDirective, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dndPlaceholderRef = _t.first);\n    }\n  },\n  hostBindings: function DndDropzoneDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"drop\", function DndDropzoneDirective_drop_HostBindingHandler($event) {\n        return ctx.onDrop($event);\n      });\n    }\n  },\n  inputs: {\n    dndDropzone: \"dndDropzone\",\n    dndEffectAllowed: \"dndEffectAllowed\",\n    dndAllowExternal: \"dndAllowExternal\",\n    dndHorizontal: \"dndHorizontal\",\n    dndDragoverClass: \"dndDragoverClass\",\n    dndDropzoneDisabledClass: \"dndDropzoneDisabledClass\",\n    dndDisableIf: \"dndDisableIf\",\n    dndDisableDropIf: \"dndDisableDropIf\"\n  },\n  outputs: {\n    dndDragover: \"dndDragover\",\n    dndDrop: \"dndDrop\"\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DndDropzoneDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndDropzone]\"\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }];\n  }, {\n    dndDropzone: [{\n      type: Input\n    }],\n    dndEffectAllowed: [{\n      type: Input\n    }],\n    dndAllowExternal: [{\n      type: Input\n    }],\n    dndHorizontal: [{\n      type: Input\n    }],\n    dndDragoverClass: [{\n      type: Input\n    }],\n    dndDropzoneDisabledClass: [{\n      type: Input\n    }],\n    dndDragover: [{\n      type: Output\n    }],\n    dndDrop: [{\n      type: Output\n    }],\n    dndPlaceholderRef: [{\n      type: ContentChild,\n      args: [DndPlaceholderRefDirective]\n    }],\n    dndDisableIf: [{\n      type: Input\n    }],\n    dndDisableDropIf: [{\n      type: Input\n    }],\n    onDrop: [{\n      type: HostListener,\n      args: [\"drop\", [\"$event\"]]\n    }]\n  });\n})();\n\nclass DndHandleDirective {\n  constructor(parent) {\n    this.draggable = true;\n    parent.registerDragHandle(this);\n  }\n\n  onDragEvent(event) {\n    event._dndUsingHandle = true;\n  }\n\n}\n\nDndHandleDirective.ɵfac = function DndHandleDirective_Factory(t) {\n  return new (t || DndHandleDirective)(i0.ɵɵdirectiveInject(DndDraggableDirective));\n};\n\nDndHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: DndHandleDirective,\n  selectors: [[\"\", \"dndHandle\", \"\"]],\n  hostVars: 1,\n  hostBindings: function DndHandleDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"dragstart\", function DndHandleDirective_dragstart_HostBindingHandler($event) {\n        return ctx.onDragEvent($event);\n      })(\"dragend\", function DndHandleDirective_dragend_HostBindingHandler($event) {\n        return ctx.onDragEvent($event);\n      });\n    }\n\n    if (rf & 2) {\n      i0.ɵɵattribute(\"draggable\", ctx.draggable);\n    }\n  }\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DndHandleDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[dndHandle]\"\n    }]\n  }], function () {\n    return [{\n      type: DndDraggableDirective\n    }];\n  }, {\n    draggable: [{\n      type: HostBinding,\n      args: [\"attr.draggable\"]\n    }],\n    onDragEvent: [{\n      type: HostListener,\n      args: [\"dragstart\", [\"$event\"]]\n    }, {\n      type: HostListener,\n      args: [\"dragend\", [\"$event\"]]\n    }]\n  });\n})();\n\nclass DndModule {}\n\nDndModule.ɵfac = function DndModule_Factory(t) {\n  return new (t || DndModule)();\n};\n\nDndModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: DndModule\n});\nDndModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [CommonModule]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DndModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndPlaceholderRefDirective, DndDragImageRefDirective],\n      exports: [DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndPlaceholderRefDirective, DndDragImageRefDirective]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of dnd\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DndDragImageRefDirective, DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndModule, DndPlaceholderRefDirective };","map":{"version":3,"names":["i0","forwardRef","Directive","Inject","EventEmitter","Input","Output","HostBinding","HostListener","ContentChild","NgModule","CommonModule","DROP_EFFECTS","CUSTOM_MIME_TYPE","JSON_MIME_TYPE","MSIE_MIME_TYPE","mimeTypeIsCustom","mimeType","substr","length","getWellKnownMimeType","event","dataTransfer","types","i","setDragData","data","effectAllowed","type","dataString","JSON","stringify","setData","e","effectsAllowed","filterEffects","getDropData","dragIsExternal","parse","getData","effects","allowed","filter","effect","toLowerCase","indexOf","getDirectChildElement","parentElement","childElement","directChild","parentNode","shouldPositionPlaceholderBeforeElement","element","horizontal","bounds","getBoundingClientRect","clientX","left","width","clientY","top","height","calculateDragImageOffset","dragImage","dragImageComputedStyle","window","getComputedStyle","paddingTop","parseFloat","paddingLeft","borderTop","borderTopWidth","borderLeft","borderLeftWidth","x","offsetX","y","offsetY","setDragImage","offsetFunction","offset","_dndState","isDragging","dropEffect","undefined","startDrag","endDrag","setDropEffect","getDropEffect","dataTransferEffectAllowed","ctrlKey","altKey","getDndType","isExternalDrag","dndState","DndDragImageRefDirective","constructor","parent","elementRef","registerDragImage","ɵfac","DndDraggableDirective","ElementRef","ɵdir","args","selector","decorators","renderer","ngZone","dndEffectAllowed","dndDraggingClass","dndDraggingSourceClass","dndDraggableDisabledClass","dndDragImageOffsetFunction","dndStart","dndDrag","dndEnd","dndMoved","dndCopied","dndLinked","dndCanceled","draggable","isDragStarted","dragEventHandler","onDrag","dndDisableIf","value","removeClass","nativeElement","addClass","dndDisableDragIf","ngAfterViewInit","runOutsideAngular","addEventListener","ngOnDestroy","removeEventListener","onDragStart","dndHandle","_dndUsingHandle","dndType","dndDraggable","determineDragImage","dndDragImageElementRef","unregister","listen","emit","stopPropagation","onDragEnd","dropEffectEmitter","setTimeout","registerDragHandle","handle","Renderer2","NgZone","DndPlaceholderRefDirective","DndDropzoneDirective","dndDropzone","dndAllowExternal","dndHorizontal","dndDragoverClass","dndDropzoneDisabledClass","dndDragover","dndDrop","placeholder","disabled","dragEnterEventHandler","onDragEnter","dragOverEventHandler","onDragOver","dragLeaveEventHandler","onDragLeave","dndDisableDropIf","tryGetPlaceholder","removePlaceholderFromDOM","_dndDropzoneActive","cleanupDragoverState","newTarget","document","elementFromPoint","contains","isDropAllowed","preventDefault","defaultPrevented","checkAndUpdatePlaceholderPosition","onDrop","dropIndex","getPlaceholderIndex","isExternal","index","Array","isArray","Error","dndPlaceholderRef","querySelector","removeChild","appendChild","target","positionPlaceholderBeforeDirectChild","previousSibling","insertBefore","nextSibling","prototype","call","children","DndHandleDirective","onDragEvent","DndModule","ɵmod","ɵinj","imports","declarations","exports"],"sources":["/Users/ys-admin/Personal/todo_list_frontend/node_modules/ngx-drag-drop/fesm2020/ngx-drag-drop.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { forwardRef, Directive, Inject, EventEmitter, Input, Output, HostBinding, HostListener, ContentChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nconst DROP_EFFECTS = [\"move\", \"copy\", \"link\"];\nconst CUSTOM_MIME_TYPE = \"application/x-dnd\";\nconst JSON_MIME_TYPE = \"application/json\";\nconst MSIE_MIME_TYPE = \"Text\";\nfunction mimeTypeIsCustom(mimeType) {\n    return mimeType.substr(0, CUSTOM_MIME_TYPE.length) === CUSTOM_MIME_TYPE;\n}\nfunction getWellKnownMimeType(event) {\n    if (event.dataTransfer) {\n        const types = event.dataTransfer.types;\n        // IE 9 workaround.\n        if (!types) {\n            return MSIE_MIME_TYPE;\n        }\n        for (let i = 0; i < types.length; i++) {\n            if (types[i] === MSIE_MIME_TYPE\n                || types[i] === JSON_MIME_TYPE\n                || mimeTypeIsCustom(types[i])) {\n                return types[i];\n            }\n        }\n    }\n    return null;\n}\nfunction setDragData(event, data, effectAllowed) {\n    // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n    // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n    const mimeType = CUSTOM_MIME_TYPE + (data.type ? (\"-\" + data.type) : \"\");\n    const dataString = JSON.stringify(data);\n    try {\n        event.dataTransfer?.setData(mimeType, dataString);\n    }\n    catch (e) {\n        //   Setting a custom MIME type did not work, we are probably in IE or Edge.\n        try {\n            event.dataTransfer?.setData(JSON_MIME_TYPE, dataString);\n        }\n        catch (e) {\n            //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n            //   does not allow changing the cursor in the dragover event, therefore we have to choose\n            //   the one we want to display now by setting effectAllowed.\n            const effectsAllowed = filterEffects(DROP_EFFECTS, effectAllowed);\n            if (event.dataTransfer) {\n                event.dataTransfer.effectAllowed = effectsAllowed[0];\n            }\n            event.dataTransfer?.setData(MSIE_MIME_TYPE, dataString);\n        }\n    }\n}\nfunction getDropData(event, dragIsExternal) {\n    // check if the mime type is well known\n    const mimeType = getWellKnownMimeType(event);\n    // drag did not originate from [dndDraggable]\n    if (dragIsExternal === true) {\n        if (mimeType !== null\n            && mimeTypeIsCustom(mimeType)) {\n            // the type of content is well known and safe to handle\n            return JSON.parse(event.dataTransfer?.getData(mimeType) ?? \"{}\");\n        }\n        // the contained data is unknown, let user handle it\n        return {};\n    }\n    if (mimeType !== null) {\n        // the type of content is well known and safe to handle\n        return JSON.parse(event.dataTransfer?.getData(mimeType) ?? \"{}\");\n    }\n    // the contained data is unknown, let user handle it\n    return {};\n}\nfunction filterEffects(effects, allowed) {\n    if (allowed === \"all\"\n        || allowed === \"uninitialized\") {\n        return effects;\n    }\n    return effects.filter(function (effect) {\n        return allowed.toLowerCase().indexOf(effect) !== -1;\n    });\n}\nfunction getDirectChildElement(parentElement, childElement) {\n    let directChild = childElement;\n    while (directChild.parentNode !== parentElement) {\n        // reached root node without finding given parent\n        if (!directChild.parentNode) {\n            return null;\n        }\n        directChild = directChild.parentNode;\n    }\n    return directChild;\n}\nfunction shouldPositionPlaceholderBeforeElement(event, element, horizontal) {\n    const bounds = element.getBoundingClientRect();\n    // If the pointer is in the upper half of the list item element,\n    // we position the placeholder before the list item, otherwise after it.\n    if (horizontal) {\n        return (event.clientX < bounds.left + bounds.width / 2);\n    }\n    return (event.clientY < bounds.top + bounds.height / 2);\n}\nfunction calculateDragImageOffset(event, dragImage) {\n    const dragImageComputedStyle = window.getComputedStyle(dragImage);\n    const paddingTop = parseFloat(dragImageComputedStyle.paddingTop) || 0;\n    const paddingLeft = parseFloat(dragImageComputedStyle.paddingLeft) || 0;\n    const borderTop = parseFloat(dragImageComputedStyle.borderTopWidth) || 0;\n    const borderLeft = parseFloat(dragImageComputedStyle.borderLeftWidth) || 0;\n    return {\n        x: event.offsetX + paddingLeft + borderLeft,\n        y: event.offsetY + paddingTop + borderTop\n    };\n}\nfunction setDragImage(event, dragImage, offsetFunction) {\n    const offset = offsetFunction(event, dragImage) || { x: 0, y: 0 };\n    event.dataTransfer.setDragImage(dragImage, offset.x, offset.y);\n}\n\nconst _dndState = {\n    isDragging: false,\n    dropEffect: \"none\",\n    effectAllowed: \"all\",\n    type: undefined\n};\nfunction startDrag(event, effectAllowed, type) {\n    _dndState.isDragging = true;\n    _dndState.dropEffect = \"none\";\n    _dndState.effectAllowed = effectAllowed;\n    _dndState.type = type;\n    if (event.dataTransfer) {\n        event.dataTransfer.effectAllowed = effectAllowed;\n    }\n}\nfunction endDrag() {\n    _dndState.isDragging = false;\n    _dndState.dropEffect = undefined;\n    _dndState.effectAllowed = undefined;\n    _dndState.type = undefined;\n}\nfunction setDropEffect(event, dropEffect) {\n    if (_dndState.isDragging === true) {\n        _dndState.dropEffect = dropEffect;\n    }\n    if (event.dataTransfer) {\n        event.dataTransfer.dropEffect = dropEffect;\n    }\n}\nfunction getDropEffect(event, effectAllowed) {\n    const dataTransferEffectAllowed = (event.dataTransfer) ? event.dataTransfer.effectAllowed : \"uninitialized\";\n    let effects = filterEffects(DROP_EFFECTS, dataTransferEffectAllowed);\n    if (_dndState.isDragging === true) {\n        effects = filterEffects(effects, _dndState.effectAllowed);\n    }\n    if (effectAllowed) {\n        effects = filterEffects(effects, effectAllowed);\n    }\n    // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n    // therefore the following modifier keys will only affect other operating systems.\n    if (effects.length === 0) {\n        return \"none\";\n    }\n    if (event.ctrlKey && effects.indexOf(\"copy\") !== -1) {\n        return \"copy\";\n    }\n    if (event.altKey && effects.indexOf(\"link\") !== -1) {\n        return \"link\";\n    }\n    return effects[0];\n}\nfunction getDndType(event) {\n    if (_dndState.isDragging === true) {\n        return _dndState.type;\n    }\n    const mimeType = getWellKnownMimeType(event);\n    if (mimeType === null) {\n        return undefined;\n    }\n    if (mimeType === MSIE_MIME_TYPE\n        || mimeType === JSON_MIME_TYPE) {\n        return undefined;\n    }\n    return mimeType.substr(CUSTOM_MIME_TYPE.length + 1) || undefined;\n}\nfunction isExternalDrag() {\n    return _dndState.isDragging === false;\n}\nconst dndState = _dndState;\n\nclass DndDragImageRefDirective {\n    constructor(parent, elementRef) {\n        parent.registerDragImage(elementRef);\n    }\n}\nDndDragImageRefDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndDragImageRefDirective, deps: [{ token: forwardRef(() => DndDraggableDirective) }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\nDndDragImageRefDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: DndDragImageRefDirective, selector: \"[dndDragImageRef]\", ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndDragImageRefDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: \"[dndDragImageRef]\"\n                }]\n        }], ctorParameters: function () { return [{ type: DndDraggableDirective, decorators: [{\n                    type: Inject,\n                    args: [forwardRef(() => DndDraggableDirective)]\n                }] }, { type: i0.ElementRef }]; } });\nclass DndDraggableDirective {\n    constructor(elementRef, renderer, ngZone) {\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.ngZone = ngZone;\n        this.dndEffectAllowed = \"copy\";\n        this.dndDraggingClass = \"dndDragging\";\n        this.dndDraggingSourceClass = \"dndDraggingSource\";\n        this.dndDraggableDisabledClass = \"dndDraggableDisabled\";\n        this.dndDragImageOffsetFunction = calculateDragImageOffset;\n        this.dndStart = new EventEmitter();\n        this.dndDrag = new EventEmitter();\n        this.dndEnd = new EventEmitter();\n        this.dndMoved = new EventEmitter();\n        this.dndCopied = new EventEmitter();\n        this.dndLinked = new EventEmitter();\n        this.dndCanceled = new EventEmitter();\n        this.draggable = true;\n        this.isDragStarted = false;\n        this.dragEventHandler = (event) => this.onDrag(event);\n    }\n    set dndDisableIf(value) {\n        this.draggable = !value;\n        if (this.draggable) {\n            this.renderer.removeClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n        }\n        else {\n            this.renderer.addClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n        }\n    }\n    set dndDisableDragIf(value) {\n        this.dndDisableIf = value;\n    }\n    ngAfterViewInit() {\n        this.ngZone.runOutsideAngular(() => {\n            this.elementRef.nativeElement.addEventListener(\"drag\", this.dragEventHandler);\n        });\n    }\n    ngOnDestroy() {\n        this.elementRef.nativeElement.removeEventListener(\"drag\", this.dragEventHandler);\n        if (this.isDragStarted === true) {\n            endDrag();\n        }\n    }\n    onDragStart(event) {\n        if (this.draggable === false) {\n            return false;\n        }\n        // check if there is dnd handle and if the dnd handle was used to start the drag\n        if (typeof this.dndHandle !== \"undefined\"\n            && typeof event._dndUsingHandle === \"undefined\") {\n            return false;\n        }\n        // initialize global state\n        startDrag(event, this.dndEffectAllowed, this.dndType);\n        this.isDragStarted = true;\n        setDragData(event, { data: this.dndDraggable, type: this.dndType }, dndState.effectAllowed);\n        this.dragImage = this.determineDragImage();\n        // set dragging css class prior to setDragImage so styles are applied before\n        // TODO breaking change: add class to elementRef rather than drag image which could be another element\n        this.renderer.addClass(this.dragImage, this.dndDraggingClass);\n        // set custom dragimage if present\n        // set dragimage if drag is started from dndHandle\n        if (typeof this.dndDragImageElementRef !== \"undefined\"\n            || typeof event._dndUsingHandle !== \"undefined\") {\n            setDragImage(event, this.dragImage, this.dndDragImageOffsetFunction);\n        }\n        // add dragging source css class on first drag event\n        const unregister = this.renderer.listen(this.elementRef.nativeElement, \"drag\", () => {\n            this.renderer.addClass(this.elementRef.nativeElement, this.dndDraggingSourceClass);\n            unregister();\n        });\n        this.dndStart.emit(event);\n        event.stopPropagation();\n        return true;\n    }\n    onDrag(event) {\n        this.dndDrag.emit(event);\n    }\n    onDragEnd(event) {\n        // get drop effect from custom stored state as its not reliable across browsers\n        const dropEffect = dndState.dropEffect;\n        let dropEffectEmitter;\n        switch (dropEffect) {\n            case \"copy\":\n                dropEffectEmitter = this.dndCopied;\n                break;\n            case \"link\":\n                dropEffectEmitter = this.dndLinked;\n                break;\n            case \"move\":\n                dropEffectEmitter = this.dndMoved;\n                break;\n            default:\n                dropEffectEmitter = this.dndCanceled;\n                break;\n        }\n        dropEffectEmitter.emit(event);\n        this.dndEnd.emit(event);\n        // reset global state\n        endDrag();\n        this.isDragStarted = false;\n        this.renderer.removeClass(this.dragImage, this.dndDraggingClass);\n        // IE9 special hammering\n        window.setTimeout(() => {\n            this.renderer.removeClass(this.elementRef.nativeElement, this.dndDraggingSourceClass);\n        }, 0);\n        event.stopPropagation();\n    }\n    registerDragHandle(handle) {\n        this.dndHandle = handle;\n    }\n    registerDragImage(elementRef) {\n        this.dndDragImageElementRef = elementRef;\n    }\n    determineDragImage() {\n        // evaluate custom drag image existence\n        if (typeof this.dndDragImageElementRef !== \"undefined\") {\n            return this.dndDragImageElementRef.nativeElement;\n        }\n        else {\n            return this.elementRef.nativeElement;\n        }\n    }\n}\nDndDraggableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndDraggableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nDndDraggableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: DndDraggableDirective, selector: \"[dndDraggable]\", inputs: { dndDraggable: \"dndDraggable\", dndEffectAllowed: \"dndEffectAllowed\", dndType: \"dndType\", dndDraggingClass: \"dndDraggingClass\", dndDraggingSourceClass: \"dndDraggingSourceClass\", dndDraggableDisabledClass: \"dndDraggableDisabledClass\", dndDragImageOffsetFunction: \"dndDragImageOffsetFunction\", dndDisableIf: \"dndDisableIf\", dndDisableDragIf: \"dndDisableDragIf\" }, outputs: { dndStart: \"dndStart\", dndDrag: \"dndDrag\", dndEnd: \"dndEnd\", dndMoved: \"dndMoved\", dndCopied: \"dndCopied\", dndLinked: \"dndLinked\", dndCanceled: \"dndCanceled\" }, host: { listeners: { \"dragstart\": \"onDragStart($event)\", \"dragend\": \"onDragEnd($event)\" }, properties: { \"attr.draggable\": \"this.draggable\" } }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndDraggableDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: \"[dndDraggable]\"\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { dndDraggable: [{\n                type: Input\n            }], dndEffectAllowed: [{\n                type: Input\n            }], dndType: [{\n                type: Input\n            }], dndDraggingClass: [{\n                type: Input\n            }], dndDraggingSourceClass: [{\n                type: Input\n            }], dndDraggableDisabledClass: [{\n                type: Input\n            }], dndDragImageOffsetFunction: [{\n                type: Input\n            }], dndStart: [{\n                type: Output\n            }], dndDrag: [{\n                type: Output\n            }], dndEnd: [{\n                type: Output\n            }], dndMoved: [{\n                type: Output\n            }], dndCopied: [{\n                type: Output\n            }], dndLinked: [{\n                type: Output\n            }], dndCanceled: [{\n                type: Output\n            }], draggable: [{\n                type: HostBinding,\n                args: [\"attr.draggable\"]\n            }], dndDisableIf: [{\n                type: Input\n            }], dndDisableDragIf: [{\n                type: Input\n            }], onDragStart: [{\n                type: HostListener,\n                args: [\"dragstart\", [\"$event\"]]\n            }], onDragEnd: [{\n                type: HostListener,\n                args: [\"dragend\", [\"$event\"]]\n            }] } });\n\nclass DndPlaceholderRefDirective {\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n    }\n}\nDndPlaceholderRefDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndPlaceholderRefDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\nDndPlaceholderRefDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: DndPlaceholderRefDirective, selector: \"[dndPlaceholderRef]\", ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndPlaceholderRefDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: \"[dndPlaceholderRef]\"\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\nclass DndDropzoneDirective {\n    constructor(ngZone, elementRef, renderer) {\n        this.ngZone = ngZone;\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n        this.dndDropzone = \"\";\n        this.dndEffectAllowed = \"uninitialized\";\n        this.dndAllowExternal = false;\n        this.dndHorizontal = false;\n        this.dndDragoverClass = \"dndDragover\";\n        this.dndDropzoneDisabledClass = \"dndDropzoneDisabled\";\n        this.dndDragover = new EventEmitter();\n        this.dndDrop = new EventEmitter();\n        this.placeholder = null;\n        this.disabled = false;\n        this.dragEnterEventHandler = (event) => this.onDragEnter(event);\n        this.dragOverEventHandler = (event) => this.onDragOver(event);\n        this.dragLeaveEventHandler = (event) => this.onDragLeave(event);\n    }\n    set dndDisableIf(value) {\n        this.disabled = !!value;\n        if (this.disabled) {\n            this.renderer.addClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n        }\n        else {\n            this.renderer.removeClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n        }\n    }\n    set dndDisableDropIf(value) {\n        this.dndDisableIf = value;\n    }\n    ngAfterViewInit() {\n        this.placeholder = this.tryGetPlaceholder();\n        this.removePlaceholderFromDOM();\n        this.ngZone.runOutsideAngular(() => {\n            this.elementRef.nativeElement.addEventListener(\"dragenter\", this.dragEnterEventHandler);\n            this.elementRef.nativeElement.addEventListener(\"dragover\", this.dragOverEventHandler);\n            this.elementRef.nativeElement.addEventListener(\"dragleave\", this.dragLeaveEventHandler);\n        });\n    }\n    ngOnDestroy() {\n        this.elementRef.nativeElement.removeEventListener(\"dragenter\", this.dragEnterEventHandler);\n        this.elementRef.nativeElement.removeEventListener(\"dragover\", this.dragOverEventHandler);\n        this.elementRef.nativeElement.removeEventListener(\"dragleave\", this.dragLeaveEventHandler);\n    }\n    onDragEnter(event) {\n        // check if another dropzone is activated\n        if (event._dndDropzoneActive === true) {\n            this.cleanupDragoverState();\n            return;\n        }\n        // set as active if the target element is inside this dropzone\n        if (typeof event._dndDropzoneActive === \"undefined\") {\n            const newTarget = document.elementFromPoint(event.clientX, event.clientY);\n            if (this.elementRef.nativeElement.contains(newTarget)) {\n                event._dndDropzoneActive = true;\n            }\n        }\n        // check if this drag event is allowed to drop on this dropzone\n        const type = getDndType(event);\n        if (this.isDropAllowed(type) === false) {\n            return;\n        }\n        // allow the dragenter\n        event.preventDefault();\n    }\n    onDragOver(event) {\n        // With nested dropzones, we want to ignore this event if a child dropzone\n        // has already handled a dragover.  Historically, event.stopPropagation() was\n        // used to prevent this bubbling, but that prevents any dragovers outside the\n        // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\n        // Instead, we can check if the event was already prevented by a child and bail early.\n        if (event.defaultPrevented) {\n            return;\n        }\n        // check if this drag event is allowed to drop on this dropzone\n        const type = getDndType(event);\n        if (this.isDropAllowed(type) === false) {\n            return;\n        }\n        this.checkAndUpdatePlaceholderPosition(event);\n        const dropEffect = getDropEffect(event, this.dndEffectAllowed);\n        if (dropEffect === \"none\") {\n            this.cleanupDragoverState();\n            return;\n        }\n        // allow the dragover\n        event.preventDefault();\n        // set the drop effect\n        setDropEffect(event, dropEffect);\n        this.dndDragover.emit(event);\n        this.renderer.addClass(this.elementRef.nativeElement, this.dndDragoverClass);\n    }\n    onDrop(event) {\n        try {\n            // check if this drag event is allowed to drop on this dropzone\n            const type = getDndType(event);\n            if (this.isDropAllowed(type) === false) {\n                return;\n            }\n            const data = getDropData(event, isExternalDrag());\n            if (this.isDropAllowed(data.type) === false) {\n                return;\n            }\n            // signal custom drop handling\n            event.preventDefault();\n            const dropEffect = getDropEffect(event);\n            setDropEffect(event, dropEffect);\n            if (dropEffect === \"none\") {\n                return;\n            }\n            const dropIndex = this.getPlaceholderIndex();\n            // if for whatever reason the placeholder is not present in the DOM but it should be there\n            // we don't allow/emit the drop event since it breaks the contract\n            // seems to only happen if drag and drop is executed faster than the DOM updates\n            if (dropIndex === -1) {\n                return;\n            }\n            this.dndDrop.emit({\n                event: event,\n                dropEffect: dropEffect,\n                isExternal: isExternalDrag(),\n                data: data.data,\n                index: dropIndex,\n                type: type,\n            });\n            event.stopPropagation();\n        }\n        finally {\n            this.cleanupDragoverState();\n        }\n    }\n    onDragLeave(event) {\n        // check if still inside this dropzone and not yet handled by another dropzone\n        if (typeof event._dndDropzoneActive === \"undefined\") {\n            const newTarget = document.elementFromPoint(event.clientX, event.clientY);\n            if (this.elementRef.nativeElement.contains(newTarget)) {\n                event._dndDropzoneActive = true;\n                return;\n            }\n        }\n        this.cleanupDragoverState();\n        // cleanup drop effect when leaving dropzone\n        setDropEffect(event, \"none\");\n    }\n    isDropAllowed(type) {\n        // dropzone is disabled -> deny it\n        if (this.disabled === true) {\n            return false;\n        }\n        // if drag did not start from our directive\n        // and external drag sources are not allowed -> deny it\n        if (isExternalDrag() === true\n            && this.dndAllowExternal === false) {\n            return false;\n        }\n        // no filtering by types -> allow it\n        if (!this.dndDropzone) {\n            return true;\n        }\n        // no type set -> allow it\n        if (!type) {\n            return true;\n        }\n        if (Array.isArray(this.dndDropzone) === false) {\n            throw new Error(\"dndDropzone: bound value to [dndDropzone] must be an array!\");\n        }\n        // if dropzone contains type -> allow it\n        return this.dndDropzone.indexOf(type) !== -1;\n    }\n    tryGetPlaceholder() {\n        if (typeof this.dndPlaceholderRef !== \"undefined\") {\n            return this.dndPlaceholderRef.elementRef.nativeElement;\n        }\n        // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\n        // of wrong context see angular bug https://github.com/angular/angular/issues/13517\n        return this.elementRef.nativeElement.querySelector(\"[dndPlaceholderRef]\");\n    }\n    removePlaceholderFromDOM() {\n        if (this.placeholder !== null\n            && this.placeholder.parentNode !== null) {\n            this.placeholder.parentNode.removeChild(this.placeholder);\n        }\n    }\n    checkAndUpdatePlaceholderPosition(event) {\n        if (this.placeholder === null) {\n            return;\n        }\n        // make sure the placeholder is in the DOM\n        if (this.placeholder.parentNode !== this.elementRef.nativeElement) {\n            this.renderer.appendChild(this.elementRef.nativeElement, this.placeholder);\n        }\n        // update the position if the event originates from a child element of the dropzone\n        const directChild = getDirectChildElement(this.elementRef.nativeElement, event.target);\n        // early exit if no direct child or direct child is placeholder\n        if (directChild === null\n            || directChild === this.placeholder) {\n            return;\n        }\n        const positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement(event, directChild, this.dndHorizontal);\n        if (positionPlaceholderBeforeDirectChild) {\n            // do insert before only if necessary\n            if (directChild.previousSibling !== this.placeholder) {\n                this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild);\n            }\n        }\n        else {\n            // do insert after only if necessary\n            if (directChild.nextSibling !== this.placeholder) {\n                this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild.nextSibling);\n            }\n        }\n    }\n    getPlaceholderIndex() {\n        if (this.placeholder === null) {\n            return undefined;\n        }\n        const element = this.elementRef.nativeElement;\n        return Array.prototype.indexOf.call(element.children, this.placeholder);\n    }\n    cleanupDragoverState() {\n        this.renderer.removeClass(this.elementRef.nativeElement, this.dndDragoverClass);\n        this.removePlaceholderFromDOM();\n    }\n}\nDndDropzoneDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndDropzoneDirective, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });\nDndDropzoneDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: DndDropzoneDirective, selector: \"[dndDropzone]\", inputs: { dndDropzone: \"dndDropzone\", dndEffectAllowed: \"dndEffectAllowed\", dndAllowExternal: \"dndAllowExternal\", dndHorizontal: \"dndHorizontal\", dndDragoverClass: \"dndDragoverClass\", dndDropzoneDisabledClass: \"dndDropzoneDisabledClass\", dndDisableIf: \"dndDisableIf\", dndDisableDropIf: \"dndDisableDropIf\" }, outputs: { dndDragover: \"dndDragover\", dndDrop: \"dndDrop\" }, host: { listeners: { \"drop\": \"onDrop($event)\" } }, queries: [{ propertyName: \"dndPlaceholderRef\", first: true, predicate: DndPlaceholderRefDirective, descendants: true }], ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndDropzoneDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: \"[dndDropzone]\"\n                }]\n        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { dndDropzone: [{\n                type: Input\n            }], dndEffectAllowed: [{\n                type: Input\n            }], dndAllowExternal: [{\n                type: Input\n            }], dndHorizontal: [{\n                type: Input\n            }], dndDragoverClass: [{\n                type: Input\n            }], dndDropzoneDisabledClass: [{\n                type: Input\n            }], dndDragover: [{\n                type: Output\n            }], dndDrop: [{\n                type: Output\n            }], dndPlaceholderRef: [{\n                type: ContentChild,\n                args: [DndPlaceholderRefDirective]\n            }], dndDisableIf: [{\n                type: Input\n            }], dndDisableDropIf: [{\n                type: Input\n            }], onDrop: [{\n                type: HostListener,\n                args: [\"drop\", [\"$event\"]]\n            }] } });\n\nclass DndHandleDirective {\n    constructor(parent) {\n        this.draggable = true;\n        parent.registerDragHandle(this);\n    }\n    onDragEvent(event) {\n        event._dndUsingHandle = true;\n    }\n}\nDndHandleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndHandleDirective, deps: [{ token: DndDraggableDirective }], target: i0.ɵɵFactoryTarget.Directive });\nDndHandleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"14.2.0\", type: DndHandleDirective, selector: \"[dndHandle]\", host: { listeners: { \"dragstart\": \"onDragEvent($event)\", \"dragend\": \"onDragEvent($event)\" }, properties: { \"attr.draggable\": \"this.draggable\" } }, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndHandleDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: \"[dndHandle]\"\n                }]\n        }], ctorParameters: function () { return [{ type: DndDraggableDirective }]; }, propDecorators: { draggable: [{\n                type: HostBinding,\n                args: [\"attr.draggable\"]\n            }], onDragEvent: [{\n                type: HostListener,\n                args: [\"dragstart\", [\"$event\"]]\n            }, {\n                type: HostListener,\n                args: [\"dragend\", [\"$event\"]]\n            }] } });\n\nclass DndModule {\n}\nDndModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nDndModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"14.2.0\", ngImport: i0, type: DndModule, declarations: [DndDraggableDirective,\n        DndDropzoneDirective,\n        DndHandleDirective,\n        DndPlaceholderRefDirective,\n        DndDragImageRefDirective], imports: [CommonModule], exports: [DndDraggableDirective,\n        DndDropzoneDirective,\n        DndHandleDirective,\n        DndPlaceholderRefDirective,\n        DndDragImageRefDirective] });\nDndModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndModule, imports: [CommonModule] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"14.2.0\", ngImport: i0, type: DndModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [\n                        CommonModule\n                    ],\n                    declarations: [\n                        DndDraggableDirective,\n                        DndDropzoneDirective,\n                        DndHandleDirective,\n                        DndPlaceholderRefDirective,\n                        DndDragImageRefDirective\n                    ],\n                    exports: [\n                        DndDraggableDirective,\n                        DndDropzoneDirective,\n                        DndHandleDirective,\n                        DndPlaceholderRefDirective,\n                        DndDragImageRefDirective\n                    ]\n                }]\n        }] });\n\n/*\n * Public API Surface of dnd\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DndDragImageRefDirective, DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndModule, DndPlaceholderRefDirective };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}